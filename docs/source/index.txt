.. _home:

.. include:: README.txt

Documentation
..............................................................................

.. toctree::
   :maxdepth: 2
   
   install
   design
   class
   changes






Pickles
..............................................................................

Rtree also supports inserting pickleable objects into the index (called a clustered 
index in `libspatialindex`_ parlance).  The following inserts the 
pickleable object ``42`` into the index with the given id::

  >>> index.insert(id=id, bounds=(left, bottom, right, top), obj=42)

You can then return a list of objects by giving the ``objects=True`` flag
to intersection::

  >>> [n.object for n in idx.intersection((left, bottom, right, top), objects=True)]
  [None, None, 42]


3D indexes
..............................................................................

As of Rtree version 0.5.0, you can create 3D (actually kD) `R-trees`_. The
following is a 3D index that is to be stored on disk. Persisted indexes are
stored on disk using two files -- an index file (.idx) and a data (.dat) file.
You can modify the extensions these files use by altering the properties of
the index at instantiation time. The following creates a 3D index that is
stored on disk as the files ``3d_index.data`` and ``3d_index.index``::

  >>> from rtree import index
  >>> p = index.Property()
  >>> p.dimension = 3
  >>> p.dat_extension = 'data'
  >>> p.idx_extension = 'index'  
  >>> idx3d = index.Index('3d_index',properties=p)
  >>> idx3d.insert(1, (0, 0, 60, 60, 23.0, 42.0))
  >>> idx3d.intersection( (-1, -1, 62, 62, 22, 43))
  [1L]




Documentation and Usage
------------------------------------------------------------------------------

HTML documentation for Rtree is available at http://gispython.org/rtree/docs/ 
and they can be generated via `Sphinx`_ from the docs/ directory. 

See `tests/index.txt`_ for more detail on index usage and `tests/properties.txt`_ 
for index properties that can be set and manipulated.  `tests/test_customStorage.txt`_ 
demonstrates how to create a custom storage backend using Rtree for your own 
database.  

Refer to `libspatialindex`_ documentation or code for more detail on the meanings and usage 
of index properties.

https://mail.zope.org/pipermail/zodb-dev/2010-June/013491.html contains a custom 
storage backend for `ZODB`_

.. _tests/index.txt: http://trac.gispython.org/lab/browser/Rtree/trunk/tests/index.txt
.. _tests/properties.txt: http://trac.gispython.org/lab/browser/Rtree/trunk/tests/properties.txt
.. _tests/test_customStorage.txt: http://trac.gispython.org/lab/browser/Rtree/trunk/tests/test_customStorage.txt
.. _Sphinx: http://sphinx.pocoo.org/
.. _ZODB: http://www.zodb.org/

Performance
------------------------------------------------------------------------------

See the `tests/benchmarks.py`_ file for a comparison.

.. _tests/benchmarks.py: http://trac.gispython.org/lab/browser/Rtree/trunk/tests/benchmarks.py

There are a few simple things that will improve performance.

 - Use stream loading. This will substantially (orders of magnitude in many cases) 
   improve performance over Rtree.insert by allowing the data to be pre-sorted 
   

   :: 

       >>> def generator_function():
       ...    for i, obj in enumerate(somedata):
       ...        yield (i, (obj.xmin, obj.ymin, obj.xmax, obj.ymax), obj)
       >>> r = Rtree(generator_function())

   After bulk loading the index, you can then insert additional records into 
   the index using `insert()`

 - Override Rtree.dumps() to use the highest pickle protocol ::

    >>> import cPickle, rtree
    >>> class FastRtree(rtree.Rtree):
    ...     def dumps(self, obj):
    ...         return cPickle.dumps(obj, -1)
    >>> r = FastRtree()


 - In any query, use objects='raw' keyword argument ::

    >>> objs = r.intersection((xmin, ymin, xmax, ymax), objects="raw")

 - Adjust `rtree.index.Property` appropriate to your index.

   * Set your leaf_capacity to a higher value than the default 100.  1000+ is 
     fine for the default pagesize of 4096 in many cases.

   * Increase the fill_factor to something near 0.9.  Smaller fill factors 
     mean more splitting, which means more nodes.  This may be bad or good 
     depending on your usage.
   
 - Don't use more dimensions than you actually need. If you only need 2,
   only use two. Otherwise, you will waste lots of storage and add that 
   many more floating point comparisons for each query, search, and insert 
   operation of the index.
 
 - Use `.count()` if you only need a count and `.intersection()`
   if you only need the ids.  Otherwise, lots of data may potentially be copied.





Support
------------------------------------------------------------------------------

For current information about this project, see the wiki_.

.. _wiki: http://trac.gispython.org/lab/wiki/Rtree

If you have questions, please consider joining our community list:

http://lists.gispython.org/mailman/listinfo/community






* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

